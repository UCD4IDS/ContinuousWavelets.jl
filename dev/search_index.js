var documenterSearchIndex = {"docs":
[{"location":"spacing/#Wavelet-Frequency-Spacing","page":"Wavelet Frequency Spacing","title":"Wavelet Frequency Spacing","text":"","category":"section"},{"location":"spacing/","page":"Wavelet Frequency Spacing","title":"Wavelet Frequency Spacing","text":"Frequently, using a fixed ratio for scaling the wavelets results in too many large scale wavelets. There are several ways of dealing with this; in this package, the scaling factors have the form 2^x_0 +mx^^1_beta, for suitable choice of a,m, x_0, and beta. The user chooses beta and Q, and the rest are chosen to match the derivative at the last frequency to be ^1_Q, as in the figure.","category":"page"},{"location":"spacing/","page":"Wavelet Frequency Spacing","title":"Wavelet Frequency Spacing","text":"using ContinuousWavelets, Plots, Wavelets, FFTW, LaTeXStrings, Logging\nusing Plots;\ngr();\nPlots.reset_defaults();\ndRate = 4\nwaveType = Morlet()\nQ = 8\nnOct = 8\nΨ1 = wavelet(waveType, s=Q, β=dRate, averagingLength=2)\n# sketch of how the frequencies are chosen\nlocs = ContinuousWavelets.polySpacing(nOct, Ψ1)\na = ContinuousWavelets.getMinScaling(Ψ1) + Ψ1.averagingLength\nβ = Ψ1.β\nlastWavelet = Ψ1.Q * (nOct - a)\nb = 1 / Q * lastWavelet^((β - 1) / β)\nt = range(1, stop=length(locs), step=0.1)\ncurve = a .+ b .* (range(0, stop=lastWavelet, length=length(t))) .^ (1 / β)\nx = range(12, stop=22, step=0.5)\nycord(x) = locs[end] .+ b / β * lastWavelet .^ (1 / β - 1) .* (x .- length(locs)) * (lastWavelet - 1) / length(locs)\ny = ycord.(x)\n#Figure 3.1\nscatter(1:length(locs), locs, legend=:bottomright, label=\"mean log frequency\", xlabel=\"Wavelet Index (x)\", ylabel=\"log-Frequency (y)\", color=:black)\nscatter!(length(locs):length(locs), locs[end:end], markersize=8, markershape=:x, color=:black, facecolor=:black, label=:none)\nplot!(t, curve, color=:blue, line=:dash, label=L\"y=x_0 + mx^{^1/_\\beta}\", legend=:bottomright, legendfontsize=12, xrange=(0, length(locs) + 3), xticks=[1; 5:5:1+length(locs)...], yrange=(minimum(locs) - 1, maximum(locs) + 1), yticks=(range(floor(Int, minimum(locs)), ceil(Int, maximum(locs)), step=2), [L\"\\alpha\", (4:2:6)..., \"N.Octaves\"]))\nplot!(x, y, color=:black, line=1.5, label=:none)\nannotate!(length(locs) - 1 / 8, locs[end] + 7.5 / 16, Plots.text(L\"\\frac{\\mathrm{d}y}{\\mathrm{d}x}=^{1}/_{Q}\", 11, :black, :center))\nsavefig(\"plotOfLogCentralFrequencies.svg\")","category":"page"},{"location":"spacing/","page":"Wavelet Frequency Spacing","title":"Wavelet Frequency Spacing","text":"(Image: )","category":"page"},{"location":"spacing/","page":"Wavelet Frequency Spacing","title":"Wavelet Frequency Spacing","text":"If beta is 1, then we have a linear relation between the index and the log-frequency, and Q gives exactly the number of wavelets per octave throughout. As beta increases, the wavelets skew more and more heavily to high frequencies. The default value is 4.","category":"page"},{"location":"spacing/","page":"Wavelet Frequency Spacing","title":"Wavelet Frequency Spacing","text":"The user chooses β (the frequency decay), Q (the number of wavelets per octave at the last point), and aveLen (the number of octaves covered by the averaging function, here x_0), and then m, the number of wavelets N_w, and the spacing of x are chosen so that:","category":"page"},{"location":"spacing/","page":"Wavelet Frequency Spacing","title":"Wavelet Frequency Spacing","text":"The derivative fracmathrmdymathrmdx at the last point is ^1_Q, so the \"instantaneous\" number of wavelets x per octave y is Q. Each type of wavelet has a maximum scaling 2^N_Octaves returned by getNOctaves (generally half the signal length), so the final point N_w satisfies both y(N_w) = N_Octaves and y(N_w)=^1_Q.\nThe spacing is chosen so that there are exactly Q wavelets in the last octave.","category":"page"},{"location":"spacing/","page":"Wavelet Frequency Spacing","title":"Wavelet Frequency Spacing","text":"If you are interested in the exact computation, see the function polySpacing. As some examples of how the wavelet bank changes as we change beta:","category":"page"},{"location":"spacing/","page":"Wavelet Frequency Spacing","title":"Wavelet Frequency Spacing","text":"\nn=2047\nΨ1 = wavelet(morl, s=8, β=1)\nd1, ξ = computeWavelets(n,Ψ1)\nΨ2 = wavelet(morl, s=8, β =2)\nd2, ξ = computeWavelets(n,Ψ2)\nΨ4 = wavelet(morl, s=8, β =4)\nd4, ξ = computeWavelets(n,Ψ4)\nmatchingLimits = (minimum([d1 d2 d4]), maximum([d1 d2 d4]))#hide\nplot(heatmap(1:size(d1,2), ξ, d1, color=:Greys, yaxis = (L\"\\omega\", ), xaxis = (\"wavelet index\", ), title=L\"\\beta=1\"*\" (\"*L\"\\Psi1\"*\")\", colorbar=false, clims=matchingLimits),  heatmap(1:size(d2,2), ξ, d2, color=:Greys, yticks=[], xaxis = (\"wavelet index\", ), title=L\"\\beta=2\"*\" (\"*L\"\\Psi2\"*\")\", colorbar=false, clims=matchingLimits),  heatmap(1:size(d4,2), ξ, d4,color=:Greys, yticks=[], xticks=[1, 5, 10, 14, 18], xaxis = (\"wavelet index\", ), title=L\"\\beta=4\"*\" (\"*L\"\\Psi4\"*\")\"), layout=(1,3), clims=matchingLimits, colorbar_title=L\"\\widehat{\\psi_i}\")\nsavefig(\"changeBeta.png\") #hide","category":"page"},{"location":"spacing/","page":"Wavelet Frequency Spacing","title":"Wavelet Frequency Spacing","text":"(Image: )","category":"page"},{"location":"spacing/","page":"Wavelet Frequency Spacing","title":"Wavelet Frequency Spacing","text":"note that the low-frequency coverage increases drastically as we decrease beta.","category":"page"},{"location":"coreType/#Available-Wavelet-Families","page":"Available Wavelet Families","title":"Available Wavelet Families","text":"","category":"section"},{"location":"coreType/","page":"Available Wavelet Families","title":"Available Wavelet Families","text":"There are two tiers of wavelet types in this package. The most abstract is the ContWave type, representing a class of wavelets. This is split into several strictly continuous wavelets, and a ContOrtho<:ContWave type, which is a supertype of continuous versions of the orthogonal wavelets defined in Wavelets.jl.","category":"page"},{"location":"coreType/","page":"Available Wavelet Families","title":"Available Wavelet Families","text":"ContWave","category":"page"},{"location":"coreType/#ContinuousWavelets.ContWave","page":"Available Wavelet Families","title":"ContinuousWavelets.ContWave","text":"ContWave{Boundary,T}\n\nThe abstract type encompassing the various types of wavelets implemented in the package. The abstract type has parameters Boundary<:WaveletBoundary and T<:Number, which gives the element output type. Each has both a constructor, and a default predefined entry. These are:\n\nMorlet: A complex approximately analytic wavelet that is just a frequency   domain Gaussian with mean subtracted. Morlet(σ::T) where T<: Real. σ   gives the frequency domain variance of the mother Wavelet. As σ goes to   zero, all of the information becomes spatial. Default is morl which has   sigma=2pi.\npsihat(omega) propto textrme^-fracsigma^22big(textrme^-(sigma - omega)^2 -textrme^fracomega^2-sigma^22big)\nPaul{N}: A complex analytic wavelet, also known as Cauchy wavelets. pauln for n in 1:20 e.g. paul5\npsihat(omega) propto chi_omega geq 0 omega^Ntextrme^-omega\nMorse: A family of exactly analytic wavelets.    Morse(ga::T,be::T,cf::T) where T <: Float64. ga characterizes the    symmetry of the Morse wavelet, be can be viewed as the decay or    compactness parameter, and cf is a parameter that determines the    frequency at which the magnitude of the wavelet is maximized. \npsihat(omega) propto chi_omega geq 0(omega) omega^textrmbetextrme^-(2piomega)^textrmgatextrm  be ga geq 0\nDog{N}: Derivative of a Gaussian, where N is the number of   derivatives. dogn for n in 0:6. The Sombrero/mexican hat/Marr wavelet   is n=2.\npsihat(omega) propto omega^Ntextrme^-fracomega^22\nContOrtho{OWT}. OWT is some orthogonal wavelet of type OrthoWaveletClass   from Wavelets.jl. This uses an   explicit construction of the mother wavelet for these orthogonal wavelets   to do a continuous transform. Constructed via ContOrtho(o::W) where o   is from Wavelets.jl. Alternatively, you can get them directly as   ContOrtho objects via:\ncHaar Haar Wavelets\ncBeyl Beylkin Wavelets\ncVaid Vaidyanathan Wavelets\ncDbn Daubhechies Wavelets. n ranges from 1:Inf\ncCoifn Coiflets. n ranges from 2:2:8\ncSymn Symlets. n ranges from 4:10\ncBattn Battle-Lemarie wavelets. n ranges from 2:2:6\n\n\n\n\n\n","category":"type"},{"location":"coreType/","page":"Available Wavelet Families","title":"Available Wavelet Families","text":"using ContinuousWavelets, Plots, Wavelets, FFTW, Logging\nusing Plots; gr()\nPlots.reset_defaults()\nn= 2047;\nfunction mapTo(waveType, isReal = true, window = 1:2047; d = 1, γ = 4.0, β = 2.0, cf = 1.0, kwargs...)\n    if waveType == Morse\n        morse_wav = Morse(float(γ), float(β), float(cf))\n        c = wavelet(morse_wav; kwargs...)\n    else\n        c = wavelet(waveType; β=d, kwargs...)\n    end\n    waves, ω = computeWavelets(n, c)\n    if isReal\n        return circshift(irfft(waves, 2*n, 1), (1024, 0))[window, :]\n    else\n        waves = cat(waves, zeros(2047, size(waves, 2)), dims = 1)\n        return circshift(ifft(waves, 1), (1024, 0))[window, :]\n    end\nend\ntmp = mapTo(Morlet(π), false; averagingLength = -0.2)[:, 2]\np1 = plot([real.(tmp) imag.(tmp)], title = \"Morlet\", labels = [\"real\" \"imaginary\"], ticks = nothing, linewidth = 5)\ntmp = mapTo(paul2, false, averagingLength = -0.5)[:, 2]\np2 = plot([real.(tmp) imag.(tmp)], title = \"Paul 2\", labels = [\"real\" \"imaginary\"], ticks = nothing, linewidth = 5)\ntmpMorse1 = mapTo(Morse, false; β=3, γ=10.0, cf=1.0, averagingLength=-1)[:, 2]\np3 = plot([real.(tmpMorse1) imag.(tmpMorse1)], title = \"Morse (β=3, γ=10)\", labels = [\"real\" \"imaginary\"], ticks = nothing, linewidth = 4)\ntmpMorse2 = mapTo(Morse, false; β=1, γ=3.0, cf=1.0, averagingLength=-2)[:, 2] \np4 = plot([real.(tmpMorse2) imag.(tmpMorse2)], title = \"Morse (β=1, γ=3)\", labels = [\"real\" \"imaginary\"], ticks = nothing, linewidth = 4)\np5 = plot(mapTo(dog2; averagingLength = -1.5)[:, 2], title = \"derivative of gaussians (dog2)\", legend = false, ticks = nothing, linewidth = 5)\np6 = plot(mapTo(cHaar, true; averagingLength = 1)[:, 2], title = \"Haar\", legend = false, ticks = nothing, linewidth = 5)\np7 = plot(mapTo(cBeyl, true; d = 1, averagingLength = -0)[:, 2], title = \"Beylkyin\", legend = false, ticks = nothing, linewidth = 5)\np8 = plot(mapTo(cVaid, true; d = 1, averagingLength = -0)[:, 2], title = \"Vaidyanathan\", legend = false, ticks = nothing, linewidth = 5)\np9 = plot(mapTo(cDb2; d = 1, averagingLength = -0)[:, 2], title = \"Daubhechies 2\", legend = false, ticks = nothing, linewidth = 5)\np10 = plot(mapTo(cCoif2, true; d = 1, averagingLength = -0)[:, 2], title = \"Coiflet 2\", legend = false, ticks = nothing, linewidth = 5)\np11 = plot(mapTo(cSym4, true; d = 1, averagingLength = -0)[:, 2], title = \"Symlet 4\", legend = false, ticks = nothing, linewidth = 5)\nk = 0600;\np12 = plot(mapTo(cBatt4, true, 1024-k:1024+k; d = 1, averagingLength = -1)[:, 2], title = \"Battle-Lemarie, 4\", legend = false, ticks = nothing, linewidth = 5);\nplot(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, layout = (3, 4), size = 300 .* (5, 3.2))\nsavefig(\"mothers.svg\")#hide","category":"page"},{"location":"coreType/","page":"Available Wavelet Families","title":"Available Wavelet Families","text":"(Image: ) Above are examples of every mother wavelet family defined in this package; the only analytic and/or complex wavelets are the Morlet and the Paul wavelet families. Once you have chosen a type of wavelet, this is used to construct the more specific CWT, which specifies more details of the transform, such as frequency spacing, whether to include an averaging filter or not, a frame upper bound, etc.","category":"page"},{"location":"bound/#Boundary-Conditions","page":"Boundary Conditions","title":"Boundary Conditions","text":"","category":"section"},{"location":"bound/","page":"Boundary Conditions","title":"Boundary Conditions","text":"WaveletBoundary\nPerBoundary\nZPBoundary\nSymBoundary","category":"page"},{"location":"bound/#ContinuousWavelets.WaveletBoundary","page":"Boundary Conditions","title":"ContinuousWavelets.WaveletBoundary","text":"the abstract type for the various types of boundaries\n\n\n\n\n\n","category":"type"},{"location":"bound/#ContinuousWavelets.PerBoundary","page":"Boundary Conditions","title":"ContinuousWavelets.PerBoundary","text":"PerBoundary() <: WaveletBoundary\n\nstandard periodic boundary assumption made by the fft. Aliases of NaivePer and Periodic.\n\n\n\n\n\n","category":"type"},{"location":"bound/#ContinuousWavelets.ZPBoundary","page":"Boundary Conditions","title":"ContinuousWavelets.ZPBoundary","text":"ZPBoundary() <: WaveletBoundary\n\nzero pads the signal before doing an fft, rounding up to the nearest power of two. Alias of padded.\n\n\n\n\n\n","category":"type"},{"location":"bound/#ContinuousWavelets.SymBoundary","page":"Boundary Conditions","title":"ContinuousWavelets.SymBoundary","text":"SymBoundary() <: WaveletBoundary\n\nsymmetric boundary, as in the DCT type II. Repeats the edge value, which alleviates derivative discontinuities. Alias of DEFAULT_BOUNDARY and SymBound.\n\n\n\n\n\n","category":"type"},{"location":"README/","page":"ContinuousWavelets","title":"ContinuousWavelets","text":"DocTestFilters = [\n        r\"\\@ ContinuousWavelets .*\",\n        r\"[ +-][0-9]\\.[0-9]{3,5}e-1[5-9]\",\n        r\"[ +-][0-9]\\.[0-9]{3,5}e-[2-9][0-9]\",\n        r\"im {2,7}\",\n    ]","category":"page"},{"location":"README/#ContinuousWavelets","page":"ContinuousWavelets","title":"ContinuousWavelets","text":"","category":"section"},{"location":"README/","page":"ContinuousWavelets","title":"ContinuousWavelets","text":"(Image: Build Status) (Image: Coverage) (Image: )","category":"page"},{"location":"README/","page":"ContinuousWavelets","title":"ContinuousWavelets","text":"This package is an offshoot of Wavelets.jl for the continuous wavelets. Thanks to Felix Gerick for the initial implementation there, with extension and further adaptation by David Weber and any other contributors listed on the right. Currently, it implements 1D continuous wavelet transforms with the following mother wavelets:","category":"page"},{"location":"README/","page":"ContinuousWavelets","title":"ContinuousWavelets","text":"(Image: Mothers)","category":"page"},{"location":"README/","page":"ContinuousWavelets","title":"ContinuousWavelets","text":"Which covers several standard continuous wavelet families, both real and analytic, as well as continuous versions of the orthogonal wavelet transforms implemented in Wavelets.jl.","category":"page"},{"location":"README/#Basic-Usage","page":"ContinuousWavelets","title":"Basic Usage","text":"","category":"section"},{"location":"README/","page":"ContinuousWavelets","title":"ContinuousWavelets","text":"Install via the package manager and load with using","category":"page"},{"location":"README/","page":"ContinuousWavelets","title":"ContinuousWavelets","text":"julia> Pkg.add(\"ContinuousWavelets\")\njulia> using ContinuousWavelets","category":"page"},{"location":"README/","page":"ContinuousWavelets","title":"ContinuousWavelets","text":"Basic usage example on a doppler test function.","category":"page"},{"location":"README/","page":"ContinuousWavelets","title":"ContinuousWavelets","text":"julia> using Random\n\njulia> Random.seed!(1234);\n\njulia> using ContinuousWavelets, Wavelets\n\njulia> n = 2047;\n\njulia> t = range(0, n / 1000, length=n); # 1kHz sampling rate\n\njulia> f = testfunction(n, \"Doppler\");\n\njulia> c = wavelet(Morlet(π), β=2);\n\njulia> res = cwt(f, c)\n┌ Warning: the lowest frequency wavelet has more than 1% its max at zero, so it may not be analytic. Think carefully\n│   lowAprxAnalyt = 0.061863\n└ @ ContinuousWavelets ~/work/ContinuousWavelets.jl/ContinuousWavelets.jl/src/sanityChecks.jl:7\n2047×31 Matrix{ComplexF64}:\n -1.48637e-6+3.8241e-19im   …  0.000109978+9.67834e-5im\n -1.48602e-6+5.15534e-19im     -8.24922e-5+0.000130656im\n            ⋮               ⋱             ⋮\n 0.000435175+2.30636e-19im  …  -2.47195e-6-1.97048e-8im\n 0.000435027-8.28725e-19im     -2.63499e-6+4.62331e-8im","category":"page"},{"location":"README/","page":"ContinuousWavelets","title":"ContinuousWavelets","text":"As the cwt frame is redundant, there are many choices of dual/inverse frames. There are three available in this package, NaiveDelta(), PenroseDelta(), and DualFrames(). As a toy example, lets knock out the middle time of the bumps function and apply a high pass filter:","category":"page"},{"location":"README/","page":"ContinuousWavelets","title":"ContinuousWavelets","text":"using ContinuousWavelets, Wavelets\nf = testfunction(n, \"Bumps\");\nc = wavelet(dog2, β = 2)\nres = cwt(f, c)\n\n# output\n\n2047×27 Matrix{Float64}:\n 0.000926575  -0.00150445  …  -3.1189e-8   -2.84589e-8\n 0.000926735  -0.00150491     -2.27135e-8  -1.96595e-8\n ⋮                         ⋱   ⋮\n 0.000250708  -2.53146e-6  …  -3.11406e-9  -2.69593e-9\n 0.000250698  -2.52694e-6     -4.29947e-9  -3.92694e-9","category":"page"},{"location":"README/","page":"ContinuousWavelets","title":"ContinuousWavelets","text":"using ContinuousWavelets, Wavelets\nf = testfunction(n, \"Bumps\");\nc = wavelet(dog2, β = 2)\nres = cwt(f, c)\n# dropping the middle peaks\nres[620:1100, :] .= 0\n# and smoothing the remaining peaks\nres[:, 10:end] .= 0\nfreqs = getMeanFreq(length(f), c)\ndropped = icwt(res, c, DualFrames())\nround.(dropped,sigdigits=12)\n\n# output\n\n┌ Warning: the canonical dual frame is off by 3.81e6, consider using one of the delta dual frames\n└ @ ContinuousWavelets ~/work/ContinuousWavelets.jl/ContinuousWavelets.jl/src/sanityChecks.jl:41\n2047-element Vector{Float64}:\n 0.0069417253841\n 0.00694223965946\n ⋮\n 0.00268854944484\n 0.00268852311536","category":"page"},{"location":"README/","page":"ContinuousWavelets","title":"ContinuousWavelets","text":"It can also handle collections of examples at the same time, should you need to do a batch of transforms:","category":"page"},{"location":"README/","page":"ContinuousWavelets","title":"ContinuousWavelets","text":"julia> using Wavelets\n\njulia> exs = cat(testfunction(n, \"Doppler\"), testfunction(n, \"Blocks\"), testfunction(n, \"Bumps\"), testfunction(n, \"HeaviSine\"), dims=2);\n\njulia> c = wavelet(cDb2, β=2, extraOctaves=-0);\n\njulia> res = circshift(cwt(exs, c), (0, 1, 0))\n┌ Warning: the highest frequency wavelet has more than 1% its max at the end, so it may not be analytic. Think carefully\n│   highAprxAnalyt = 0.26753\n└ @ ContinuousWavelets ~/work/ContinuousWavelets.jl/ContinuousWavelets.jl/src/sanityChecks.jl:12\n2047×32×4 Array{Float64, 3}:\n[:, :, 1] =\n 1.88768e-5  0.000266059  …  4.67422e-5   3.00171e-6\n 8.31921e-5  0.000266939     1.56546e-5  -4.46452e-5\n ⋮                        ⋱  ⋮\n 2.25286e-6  0.00198715   …  4.24046e-6   3.80696e-6\n 2.64275e-6  0.0019801       4.37922e-6   3.47586e-6\n\n[:, :, 2] =\n  1.82235e-17  0.022676   0.00955726  …   3.2542e-18\n -1.73557e-18  0.0226846  0.0095044      -4.77282e-18\n  ⋮                                   ⋱\n  1.53669e-18  0.0341524  0.0108042   …   6.05043e-19\n  7.9713e-18   0.0342169  0.0107732       7.14045e-19\n\n[:, :, 3] =\n -4.25348e-7  0.00596895  …  4.4713e-8   1.86785e-8\n -4.37683e-7  0.00596787     3.30062e-8  7.83973e-9\n  ⋮                       ⋱  ⋮\n -9.36725e-8  0.00339937  …  7.99443e-9  4.79906e-9\n -9.31697e-8  0.00340624     8.3032e-9   4.25503e-9\n\n[:, :, 4] =\n  0.000307892  -0.0150904   -0.0039183   …   0.000301771\n  6.09684e-5   -0.0152542   -0.00405989      8.45675e-5\n  ⋮                                      ⋱\n -0.000308175  -0.00755455  -0.00156652  …  -0.000594702\n -0.000378998  -0.00746703  -0.00146187     -0.000516786","category":"page"},{"location":"README/","page":"ContinuousWavelets","title":"ContinuousWavelets","text":"And the plot of these:","category":"page"},{"location":"README/","page":"ContinuousWavelets","title":"ContinuousWavelets","text":"There are also several boundary conditions, depending on the kind of data given; the default SymBoundary() symmetrizes the data, while PerBoundary() assumes it is periodic, and ZPBoundary pads with zeros. All wavelets are stored in the Fourier domain, and all transforms consist of performing an fft (possibly an rfft if the data is real) of the input, pointwise multiplication (equivalent to convolution in the time domain), and then returning to the time domain.","category":"page"},{"location":"README/","page":"ContinuousWavelets","title":"ContinuousWavelets","text":"Perhaps somewhat unusually, the averaging function, or father wavelet, is included as an option (the bottom row for the figure above). This can be either the paired averaging function or uniform in frequency (the Dirac averaging). The frequency coverage of the wavelets can be adjusted both in total frequency range both below by the averagingLength or above by the extraOctaves (caveat emptor with how well they will be defined in that case). The frequency density can be adjusted both in terms of the quality/scale factor Q, as well as how quickly this density falls off as the frequency goes to zero via β. Finally, depending on what kind of norm you want to preserve, p determines the norm preserved in the frequency domain (so p=1 maintains the 1-norm in frequency, while p=Inf maintains the 1-norm in time).","category":"page"},{"location":"README/#Possible-extensions","page":"ContinuousWavelets","title":"Possible extensions","text":"","category":"section"},{"location":"README/","page":"ContinuousWavelets","title":"ContinuousWavelets","text":"Higher dimensional wavelets have yet to be implemented.\nA DCT implementation of the symmetric boundary to halve the space and computational costs.","category":"page"},{"location":"installation/#Installation","page":"Install","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Install","title":"Install","text":"This package is registered in the general repository, so all you need to do is press ] and run","category":"page"},{"location":"installation/","page":"Install","title":"Install","text":"(@v9.9) pkg> add ContinuousWavelets","category":"page"},{"location":"CWTConstruction/#CWT-Construction","page":"CWT Construction","title":"CWT Construction","text":"","category":"section"},{"location":"CWTConstruction/","page":"CWT Construction","title":"CWT Construction","text":"CWT\nContinuousWavelets.wavelet(::WC) where {WC<:ContinuousWavelets.ContWaveClass}","category":"page"},{"location":"CWTConstruction/#ContinuousWavelets.CWT","page":"CWT Construction","title":"ContinuousWavelets.CWT","text":"CWT(wave::ContWaveClass, Q=8, boundary::WaveletBoundary=SymBoundary(),\naveragingType::Average = Father(), averagingLength::Int = 4, frameBound=1, p::N=Inf, β=4)\n\n\n\n\n\n","category":"type"},{"location":"CWTConstruction/#Wavelets.WT.wavelet-Tuple{WC} where WC<:ContinuousWavelets.ContWaveClass","page":"CWT Construction","title":"Wavelets.WT.wavelet","text":"wavelet(wave::ContWaveClass; Q=8, boundary::WaveletBoundary=DEFAULT_BOUNDARY,\naveragingType::Average = Father(), averagingLength = 4,\nframeBound=1, p=Inf, β=4, kwargs...)\n\nA constructor for the CWT type, using keyword rather than positional options.\n\n\n\n\n\n","category":"method"},{"location":"CWTConstruction/","page":"CWT Construction","title":"CWT Construction","text":"The ContWaveClass type defines the kind of mother and father wavelet function.  The CWT type, in contrast, defines everything else that goes into performing a continuous wavelet transform besides that choice. The function wavelet() has been overloaded to work with ContWaveClass in much the same way it works for the owts of Wavelets.jl. In more detail, the parameters, along with their defaults, are:","category":"page"},{"location":"CWTConstruction/","page":"CWT Construction","title":"CWT Construction","text":"wave::ContWaveClass: is a type of continuous wavelet, see the Available Wavelet Families.\nscalingFactor, s, or Q::Real=8.0: the number of wavelets between the octaves 2^J and 2^J+1 (defaults to 8, which is most appropriate for music and other audio). Valid range is (0infty).\nβ::Real=4.0: As using exactly Q wavelets per octave leads to excessively many low-frequency wavelets, β varies the number of wavelets per octave, with larger values of β corresponding to fewer low frequency wavelets(see Wavelet Frequency Spacing for details). Valid range is (1infty), though around β=6 the spacing is approximately linear in frequency, rather than log-frequency, and begins to become concave after that.\nboundary::WaveletBoundary=SymBoundary(): The default boundary condition is SymBoundary(), implemented by appending a flipped version of the vector at the end to eliminate edge discontinuities. See Boundary Conditions for the other possibilities. \naveragingType::Average=Father(): determines whether or not to include the averaging function, and if so, what kind of averaging. The options are\nFather: use the averaging function that corresponds to the mother Wavelet.\nDirac: use the sinc function with the appropriate width.\nNoAve: don't average. this has one fewer filters than the other averagingTypes\naveragingLength::Int=4:  the number of wavelet octaves that are covered by the averaging, \nframeBound::Real=1: gives the total norm of the whole collection, corresponding to the upper frame bound; if you don't want to impose a particular bound, set frameBound<0.\nnormalization or p::Real=Inf: the p-norm preserved as the scale changes, so if we're scaling by s, normalization has value p, and the mother wavelet is psi, then the resulting wavelet is s^1ppsi(^t_s). The default scaling, Inf gives all the same maximum value in the frequency domain. Valid range is (0infty, though p1 isn't actually preserving a norm.","category":"page"},{"location":"#ContinuousWavelets-Documentation","page":"basic usage","title":"ContinuousWavelets Documentation","text":"","category":"section"},{"location":"","page":"basic usage","title":"basic usage","text":"Originally included in Wavelets.jl, this is a fork containing the types and methods specifically for doing continuous wavelet transforms. Current methods only include 1D wavelet transforms and their inverses.","category":"page"},{"location":"","page":"basic usage","title":"basic usage","text":"The basic structure is similar to that of Wavelets.jl; first you choose one of the Available Wavelet Families of the ContWaveClass type, e.g. Morlet(2π). Then you set the general transform parameters via CWT Construction, which specifies such properties as whether to average, the scaling rate, or the boundary conditions. Finally, you perform the actual transform withcwt.","category":"page"},{"location":"","page":"basic usage","title":"basic usage","text":"using Plots; gr(); #hide\nPlots.reset_defaults(); #hide\nusing ContinuousWavelets, Plots, Wavelets, FFTW\nn=2047;\nf = testfunction(n, \"Doppler\");\np1=plot(f,legend=false,title=\"Doppler\",xlims=(0,2000));\nc = wavelet(Morlet(π), averagingType=NoAve(), β=2);\nres = cwt(f, c)\np2=heatmap(abs.(res)', xlabel= \"time index\",\n\tylabel=\"frequency index\",colorbar=false);\nl=@layout [a{.3h};b{.7h}]\nplot(p1,p2,layout=l);","category":"page"},{"location":"","page":"basic usage","title":"basic usage","text":"There are 4 warnings you may see with some regularity:","category":"page"},{"location":"","page":"basic usage","title":"basic usage","text":"julia> c = wavelet(Morlet(π), averagingType=NoAve(), β=2);\n\njulia> res = cwt(f, c);","category":"page"},{"location":"","page":"basic usage","title":"basic usage","text":"This comes from checking the value of the wavelets at 0 frequency. For quasi-analytic wavelets such as Morlet wavelets, this means that there is significant non-zero mass in the negative frequency domain, which causes significant distortion. Solvable either by increasing aveLen or increasing the mother wavelet mean frequency.","category":"page"},{"location":"","page":"basic usage","title":"basic usage","text":"julia> c = wavelet(Morlet(1.5π), averagingType=NoAve(), β=2,extraOctaves=10);\n\njulia> res = cwt(f, c);","category":"page"},{"location":"","page":"basic usage","title":"basic usage","text":"This occurs because some of the constructed wavelets have significant mass beyond above the frequency resolution achievable for this signal length. Usually solvable by simply decreasing extraOctaves.","category":"page"},{"location":"","page":"basic usage","title":"basic usage","text":"julia> c = wavelet(Morlet(1.5π), averagingType=NoAve(), p=1);\n\njulia> res = cwt(f, c);","category":"page"},{"location":"","page":"basic usage","title":"basic usage","text":"These two almost always occur together as having peaks sufficiently far apart is an easy way for some frequencies to have insufficient coverage. It is to some degree unavoidable for small values of p which governs which Fourier domain norm is preserved as we change the scale.","category":"page"},{"location":"","page":"basic usage","title":"basic usage","text":"","category":"page"},{"location":"inverse/","page":"Inversion","title":"Inversion","text":"using ContinuousWavelets, Plots, Wavelets, FFTW, Logging\nusing Plots; gr()\nPlots.reset_defaults()","category":"page"},{"location":"inverse/#Wavelet-Inversion","page":"Inversion","title":"Wavelet Inversion","text":"","category":"section"},{"location":"inverse/","page":"Inversion","title":"Inversion","text":"The continuous wavelet transform is a redundant shift-invariant frame transform. As such, there isn't a single inverse transform, although there is a canonical pseudo-inverse. For more see, for example, chapter 5 of A Wavelet Tour of Signal Processing.","category":"page"},{"location":"inverse/","page":"Inversion","title":"Inversion","text":"In this package, we have 3 pseudo-inverses:","category":"page"},{"location":"inverse/","page":"Inversion","title":"Inversion","text":"icwt","category":"page"},{"location":"inverse/#ContinuousWavelets.icwt","page":"Inversion","title":"ContinuousWavelets.icwt","text":"icwt(res::AbstractArray, cWav::CWT, inverseStyle::InverseType=PenroseDelta())\n\nCompute the inverse wavelet transform using one of three dual frames. The default uses delta functions with weights chosen via a least squares method, the PenroseDelta() below. This is chosen as a default because the Morlet wavelets tend to fail catastrophically using the canonical dual frame (the dualFrames() type).\n\nicwt(res::AbstractArray, cWav::CWT, inverseStyle::PenroseDelta)\n\nReturn the inverse continuous wavelet transform, computed using the simple dual frame β_jδ_ji, where β_j is chosen to solve the least squares problem Wβ-1_2^2, where W is the Fourier domain representation of the cWav wavelets. In both this case and NaiveDelta(), the fourier transform of δ is the constant function, thus this least squares problem.\n\nicwt(res::AbstractArray, cWav::CWT, inverseStyle::NaiveDelta)\n\nReturn the inverse continuous wavelet transform, computed using the simple dual frame β_jδ_ji, where β_j is chosen to negate the scale factor (^1_s)^^1_p. Generally less accurate than choosing the weights using PenroseDelta. This is the method discussed in Torrence and Compo.\n\nicwt(res::AbstractArray, cWav::CWT, inverseStyle::DualFrames)\n\nReturn the inverse continuous wavelet transform, computed using the canonical dual frame tildewidehatψ = fracψ_n(ω)_nψ_n(ω)^2. The algorithm is to compute the cwt again, but using the canonical dual frame; consequentially, it is the most computationally intensive of the three algorithms, and typically the best behaved. Will be numerically unstable if the high frequencies of all of the wavelets are too small however, and tends to fail spectacularly in this case.\n\n\n\n\n\n","category":"function"}]
}
